#requires -Version 3.0

param
(
    [Parameter(Position=0, Mandatory=$true)][ValidateNotNullOrEmpty()][string]
    $csName,
    [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][string]
    [ValidateSet("MsSql", "Oracle", "MySql", "SqlAnywhere", "Ads", "Firebird", "SqlCe", "Azure", "VistaDb", "SQLite", "PostgreSql")]
    $backend,
    [Parameter(Mandatory=$false)][string]
    $namespace,
    [Parameter(Mandatory=$false)][string]
    $contextName,
    [Parameter(Mandatory=$false)][string]
    $settingsFilePath = "",
    [Parameter(Mandatory=$false)][switch]
    $useSqlTypes
)

$script:ErrorActionPreference = "Stop"

if([string]::IsNullOrEmpty($PSScriptRoot))
{
    $PSScriptRoot = $MyInvocation.MyCommand.Path | Split-Path
    Write-Host '$PSScriptRoot is set to ' $PSScriptRoot -ForegroundColor Yellow
}

# CONFIGURATION FLAGS
$Global:useBackendIndependentMapping = !$useSqlTypes

# Global variables
$Global:projectDir = Join-Path $PSScriptRoot "\..\"
$toolDir = $PSScriptRoot
$Global:referencePath = Join-Path $toolDir \lib
$Global:templatesPath = Join-Path $toolDir \Templates\CS
$Global:outputPath = Join-Path $Global:projectDir \Entities\Generated # TODO: adjust for real project!
$Global:contextOutputPath = $Global:outputPath
$Global:mappingOutputPath = $Global:outputPath
$Global:entityClassOutputPath = $Global:outputPath
$Global:fileSuffix = ""
$scriptName = Split-Path $MyInvocation.MyCommand.Path -Leaf
$Global:preamble = "//---------------------------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Telerik.DataAccess.Fluent.CodeGeneration $scriptName script
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
//     To extend this class please create an additional partial class definition and put your code there.
// </auto-generated>
//---------------------------------------------------------------------------------------------------------

"

# some defaults
$Global:providerName = "System.Data.SqlClient" # real value is loaded during Perform-Mapping function

# TODO: Development note
# We are using NuGet variable replacement (hence the .pp extension)
# beware of valid PowerShell statements matching the following Regex "\$\w+\$" 
# as they will be replaced during installation most probably with empty string
# If you are modifying the script after it has been installed in you project you are safe to use PowerShell variable next to each other

if([string]::IsNullOrWhiteSpace($namespace))
{
    $namespace = "ApplicationLib.Entities"
}

if([string]::IsNullOrWhiteSpace($contextName))
{
    $contextName = $csName+"EntitiesModel"
}


function Load-ModelConfiguration
{
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNullOrEmpty()][string]
        $projectDir
    )

    [xml] $projFile = Get-Content (Get-ChildItem $projectDir *.csproj).FullName
    # [string] $namespace = $projFile.Project.PropertyGroup[0].RootNamespace.Trim()
    [string] $defaultConfig = $projFile.Project.PropertyGroup[0].Configuration.InnerText.Trim()
    $ignoreTables = ("oakeygen")

    # how to set global variable
    #Set-Variable -Name $varName -Value ($a + $b) -Scope Global

    # use Tuple as return type - https://blogs.technet.microsoft.com/heyscriptingguy/2014/09/03/using-and-understanding-tuples-in-powershell/
    return [tuple]::Create($namespace, $defaultConfig, $ignoreTables)
}

function Perform-Mapping 
{
    # TODO: consider getting connString and provider names as arguments

    [OutputType([Telerik.OpenAccess.Metadata.MetadataContainer])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $csName,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $backend
    )

    # set some defaults that will be changed if we can read configuration
    $connString = $csName
    $provider = "System.Data.SqlClient"
    
    # read connection details from app.config
    [xml]$appConfig = Get-Content $Global:projectDir\app.config
    if(!$appConfig)
    {
        $appConfig = Get-Content $Global:projectDir\Web.config
    }

    if($appConfig)
    {
        $node = $appConfig.SelectSingleNode("/configuration/connectionStrings/add[@name='$csName']")
        if($node)
        {
            $connString = $node.connectionString
            $provider = $node.providerName
            $Global:providerName = $provider
        }
    }

    $mapper = New-Object Telerik.OpenAccess.API.MetaData.DatabaseModelMapper
    #remove default "_" field prefix
    $mapper.NamingSettings.FieldRules.AddPrefix = ""
    [Telerik.OpenAccess.Metadata.MetadataContainer] $md = $mapper.Map($connString, $provider, $backend)
    Return $md
}

function Generate-EntityClass
{
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaPersistentType]
        $pType,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][string]
        $template,
        [Parameter(Position=2, Mandatory=$true)][ValidateNotNullOrEmpty()][string]
        $primitivePropTemplate,
        [Parameter(Position=3, Mandatory=$true)][ValidateNotNullOrEmpty()][string]
        $navRefPropTemplate,
        [Parameter(Position=4, Mandatory=$true)][ValidateNotNullOrEmpty()][string]
        $navListPropTemplate
    )

    $primitiveMembers = $pType.Members | Where-Object { $_.GetType().Name -eq "MetaPrimitiveMember" }
    if($primitiveMembers)
    {
        $primitiveProps = Generate-PrimitiveProperties $primitiveMembers $primitivePropTemplate
    }
    $navigationMembers = $pType.Members | Where-Object { $_.GetType().Name -eq "MetaNavigationMember" }
    if($navigationMembers)
    {
        $navProps = Generate-NavigationProperties $navigationMembers $navRefPropTemplate $navListPropTemplate
    }
    else
    {
        $navProps = ""
    }

    # calculate any extra using namespace statements
    $extraNamespacesSet = New-Object 'System.Collections.Generic.HashSet[string]'
    foreach($member in $pType.Members)
    {
        $memberClrType = $member.MemberType.ClrType
        $ns = $memberClrType.Namespace
        if(([string]::IsNullOrWhiteSpace($ns) -eq $false) -and ($ns -ne "System") -and ($ns -ne "System.Collections.Generic") -and ($extraNamespacesSet.Contains($ns) -eq $false) -and ($ns -ne $namespace))
        {
            $extraNamespacesSet.Add($ns)
        }
    }
    #$extraNamespacesSet.Sort()
    if($extraNamespacesSet.Count -gt 0)
	{
		$tmp = $extraNamespacesSet | % { "using $_;"}
		$extraNamespaces = [string]::Join("`r`n", $tmp)
	}
	else
	{
		$extraNamespaces = "" #TODO: try to backspace a bit to reduce the blank lines
	}

    $class = Invoke-Expression "@`"`r`n$template`r`n`"@"
    $file = $pType.Name;
    $fileName = "$Global:entityClassOutputPath\$file"+"$Global:fileSuffix.cs"
    Write-File $fileName $class
}

function Generate-PrimitiveProperties
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][System.Collections.Generic.List[Telerik.OpenAccess.Metadata.MetaPrimitiveMember]]
        $members,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $template
    )

    if(!$members)
    {
        Return ""
    }

    $result = ""
    foreach($member in $members)
    {
        $type = Get-TypeName $member.MemberType.ClrType
        $fieldName = $member.Name;
        $propName = $member.PropertyName
        $result += Invoke-Expression "@`"`r`n$template`r`n`"@"
        $result += "`r`n"
    }

    Return $result
}

function Generate-NavigationProperties
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][System.Collections.Generic.List[Telerik.OpenAccess.Metadata.MetaNavigationMember]]
        $members,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $refTemplate,
        [Parameter(Position=2, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $listTemplate
    )

    
    if(!$members)
    {
        Return ""
    }

    $result = ""
    foreach($member in $members)
    {
        $type = $member.MemberType.Name
        $fieldName = $member.Name
        $propName = $member.PropertyName

        if($member.Multiplicity -eq "Many")
        {
            $result += Invoke-Expression "@`"`r`n$listTemplate`r`n`"@"
            $result += "`r`n"
        }
        else
        {
            $result += Invoke-Expression "@`"`r`n$refTemplate`r`n`"@"
            $result += "`r`n"
        }
    }

    Return $result
}

function Get-TypeName
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][System.Type]
        $clrType
    )

    if($clrType.IsGenericType)
    {
        if($clrType.FullName.StartsWith("System.Nullable``1"))
        {
            Return (Get-ClrTypeName $clrType.GetGenericArguments()[0]) + "?"
        }
        else
        {
            $args = $clrType.GetGenericArguments() | % { Get-ClrTypeName $_ }
            Return $clrType.Name.Substring(0, $clrType.Name.Length-2) + "<" + ($args -join ", ") + ">"
        }
    }
    else 
    {
#        if($clrType.IsArray)
#        {
#            Return (Get-ClrTypeName $clrType) + "[]"
#        }
#        else
#        {
            Return Get-ClrTypeName $clrType
#        }
    }
}

function Get-ClrTypeName
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][System.Type]
        $type
    )

    switch ($type.FullName)
    {
        System.Byte { Return "byte" }
        System.Int16 { Return "short" }
        System.Int32 { Return "int" }
        System.Int64 { Return "long" }
        System.UInt16 { Return "ushort" }
        System.UInt32 { Return "uint" }
        System.UInt64 { Return "ulong" }
        System.Float { Return "float" }
        System.Double { Return "double" }
        System.String { Return "string" }
        System.Bool { Return "bool" }
        default { Return $type.Name }
    }
}

function Generate-Mapping
{
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetadataContainer]
        $metadata,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $contextName,
        [Parameter(Position=2, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $namespace,
        [Parameter(Position=3, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $sourceTemplate,
        [Parameter(Position=4, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $mapTypeTemplate,
        [Parameter(Position=5, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $identityPropTemplate,
        [Parameter(Position=6, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $primitivePropTemplate,
        [Parameter(Position=7, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $associationTemplate,
        [Parameter(Position=8, Mandatory=$true)][ValidateNotNull()]
        $ignoreTables
    )

    $name = $contextName + "MetadataSource"

    foreach($pType in $metadata.PersistentTypes | ? { !$ignoreTables.Contains($_.Table.Name) } )
    {
        $methodName = "Get" + ($pType.Name) + "Configuration"
        $getConfigurationCalls += "                this.$methodName(),`r`n"

        $mappings += Generate-TypeMapping $pType $methodName $mapTypeTemplate $identityPropTemplate $primitivePropTemplate $associationTemplate
        $mappings += "`r`n`r`n"
    }

    $result = Invoke-Expression "@`"`r`n$sourceTemplate`r`n`"@"
    $fileName = "$Global:mappingOutputPath\$name"+"$Global:fileSuffix.cs"
    Write-File $fileName $result
}

function Generate-TypeMapping
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaPersistentType]
        $pType,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $methodName,
        [Parameter(Position=2, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $methodTemplate,
        [Parameter(Position=3, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $identityPropTemplate,
        [Parameter(Position=4, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $primitivePropTemplate,
        [Parameter(Position=5, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $associationTemplate
    )

    $type = $pType.Name
    $concurrency = $pType.OptimisticConcurrencyControlStrategy
    if([System.String]::IsNullOrWhiteSpace($pType.Table.SchemaName))
    {
        $tableName = $pType.Table.Name
    }
    else
    {
        $tableName = $pType.Table.SchemaName + "." + $pType.Table.Name
    }

    $idProps = $pType.Members | ? { $_.IsIdentity }
    foreach($idProp in $idProps)
    {
        $propName = $idProp.PropertyName
        if($idProp.MemberType.ClrType -ne [System.String])
        {
            # for non-autoinc keys we can read VOA_KEYGEN table and derive the keygen from there
            $keyGen = "KeyGenerator." + $pType.KeyGeneratorName
        }
        else
        {
            $keyGen = ""
        }
        
        $fieldName = $idProp.Name
        $columnName = $idProp.Column.Name
        $config = Get-PropertyConfiguration $idProp

        $identityProps += Invoke-Expression "@`"`r`n$identityPropTemplate`r`n`"@"
        #$identityProps += "`r`n"
    }

    $primProps = $pType.Members | ? { ($_.GetType().Name -eq "MetaPrimitiveMember") -and (!$_.IsIdentity) }
    foreach($primProp in $primProps)
    {
        $propName = $primProp.PropertyName
        $fieldName = $primProp.Name
        $columnName = $primProp.Column.Name
        if(!$primProp.Column.IsNullable)
        {
            $nullable = "NotNullable"
        }
        else
        {
            $nullable = "Nullable"
        }
        $config = Get-PropertyConfiguration $primProp

        $primitiveProps += Invoke-Expression "@`"`r`n$primitivePropTemplate`r`n`"@"
        $primitiveProps += "`r`n"
    }

    $associations = ""
    $navProps = $pType.Members | ? { ($_.GetType().Name -eq "MetaNavigationMember") -and (!$_.IsIdentity) }
    foreach($navProp in $navProps)
    {
        $ownPropName = $navProp.PropertyName
        $fieldName = $navProp.Name

        $config = Get-AssociationConfiguration $navProp

        $associations += Invoke-Expression "@`"`r`n$associationTemplate`r`n`r`n`"@"
    }

    $result = Invoke-Expression "@`"`r`n$methodTemplate`r`n`"@"
    Return $result
}

function Get-PropertyConfiguration
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaPrimitiveMember]
        $propMember
    )
    $indent = "                " # improve formating with some whitespace :)

    $result = "`r`n" # improve formating :)

    $openAccessType = [Enum]::ToObject([Telerik.OpenAccess.OpenAccessType], $propMember.Column.AdoType)
    if($Global:useBackendIndependentMapping)
    {
        $result += "$indent.WithOpenAccessType(OpenAccessType.$openAccessType)"
    }
    else
    {
        $sqlType = $propMember.Column.SqlType
        $result += "$indent.HasColumnType(""$sqlType"")"
    }

    # string types - set length
    if(($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::StringFixedLength) -or 
       ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::StringVariableLength) -or
       ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::UnicodeStringFixedLength) -or
       ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::UnicodeStringVariableLength) -or
       ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::Varchar) -or 
       ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::LongVarchar))
    {
        $result+= "`r`n$indent.HasLength("+ $propMember.Column.Length +")"
    } 
    # float types - set length and precision
    elseif(($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::Real) -or
           ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::Float) -or
           ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::Double) -or
           ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::Decimal))
    { 
        $result += "`r`n$indent.HasPrecision("+ $propMember.Column.Length +")`r`n$indent.HasScale("+ $propMember.Column.Scale +")" 
    }
    elseif(($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::Numeric) -or
           ($openAccessType -eq [Telerik.OpenAccess.OpenAccessType]::Currency))
    {
        if($Global:useBackendIndependentMapping)
        {
            $result += "`r`n$indent.Is" + $openAccessType + "()"
        }
        $result += "`r`n$indent.HasPrecision("+ $propMember.Column.Length +")`r`n$indent.HasScale("+ $propMember.Column.Scale +")" 
    } 

    if($propMember.Column.IsBackendCalculated)
    {
        $result +="`r`n$indent.HasDefaultValue()"
    }

    return $result
}

function Get-AssociationConfiguration
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaNavigationMember]
        $propMember
    )
    $indent = "                "
    $result = ""

    $loadBehavior = $propMember.LoadingBehavior
    #$result += "`r`n$indent.WithLoadBehaviour(LoadBehavior.$loadBehavior)"

    $toColumn = Generate-ToColumnForAssociation $propMember
    if($toColumn -and $toColumn.Length -gt 0)
    {
        $result += "`r`n$indent"+$toColumn
    }

    $oppositeMember = $propMember.GetOppositeMember()
    if($oppositeMember -and $oppositeMember.IsVisible -and $oppositeMember.PropertyName.Length -gt 0)
    {
        $oppositeMemberName = $oppositeMember.PropertyName
        $result += "`r`n$indent.WithOpposite(x => x.$oppositeMemberName)"
    }

    #isManaged
    #IdDependent
    #DataAccessKind

    $hasConstraint = Generate-HasConstraint $propMember
    if($hasConstraint -and $hasConstraint.Length -gt 0)
    {
        $result += "`r`n$indent"+$hasConstraint
    }


    #OrderBy
    $mapJoinTable = Generate-MapJoinTable $propMember
    if($mapJoinTable -and $mapJoinTable.Length -gt 0)
    {
        $result += "`r`n$indent"+$mapJoinTable
    }

    #IsRequired
    if(($propMember.Multiplicity -eq [Telerik.OpenAccess.Metadata.Multiplicity]::One) -or
       (($propMember.Association.AssociationType -eq [Telerik.OpenAccess.Metadata.AssociationType]::OneToOne) -and
        (($propMember -eq $propMember.Association.SourceEnd) -or $propMember.Association.HasSingleEnd())))
    {
        $result += "`r`n$indent.IsRequired()"
    }

    return $result
}

function Generate-HasConstraint
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaNavigationMember]
        $propMember
    )

    $association = $propMember.Association -as [Telerik.OpenAccess.Metadata.MetaForeignKeyAssociation]
    if(!$association)
    { return "" }

    $parts = [Telerik.OpenAccess.Metadata.MetadataWorker]::GetAssociationPartsForAssociation($association, [Telerik.OpenAccess.Metadata.AssociationPartType]::ForeignKey)
    if(!$association.Constraint -and $parts.Count -eq 1)
    { return "" }

    $primitiveMembers = $association.GetSourceConceptualKeys()
    if($primitiveMembers.Count -eq 0)
    {
        $primitiveMembers = $association.GetSourceRelationalKeys() | % { [Telerik.OpenAccess.Metadata.MetadataWorker]::FindMetaPrimitiveMemberMappedToColumn($_, $propMember.DeclaringType) } 
    }

    $constraintDefinitionTokens = @()
    $targetMembers = $association.GetTargetConceptualKeys()
    if($primitiveMembers.Count -eq $targetMembers.Count)
    {
        for($i = 0; $i -lt $primitiveMembers.Count; $i++)
        {
            $sourceMember = $primitiveMembers[$i]
            $targetMember = $targetMembers[$i]
            if($sourceMember -and $targetMember -and $sourceMember.IsVisible -and $targetMember.IsVisible)
            {
                $constraintToken = " x.{0} == y.{1} " -f $sourceMember.PropertyName, $targetMember.PropertyName
                $constraintDefinitionTokens = $constraintDefinitionTokens + $constraintToken
            }
        }
    }

    if($constraintDefinitionTokens.Count -gt 0)
    {
        if($association.SourceEnd -eq $propMember)
        {
            $paramsToken = "(x, y)"
        }
        else
        {
            $paramsToken = "(y, x)"
        }
        $joinedTokens = [System.String]::Join("&&", $constraintDefinitionTokens)
        return ".HasConstraint({0} => {1})" -f $paramsToken, $joinedTokens
    }
    else
    {
        return ".HasConstraint()"
    }
}

function Generate-ToColumnForAssociation
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaNavigationMember]
        $propMember
    )

    $association = $propMember.Association -as [Telerik.OpenAccess.Metadata.MetaForeignKeyAssociation]
    if(!$association)
    { return "" }

    $parts = [Telerik.OpenAccess.Metadata.MetadataWorker]::GetAssociationPartsForAssociation($association, [Telerik.OpenAccess.Metadata.AssociationPartType]::ForeignKey)
    if($parts.Count -ne 1)
    { return "" }

    $column = $parts[0].ForeignKeyColumn
    if(!$column)
    {
        $column = $parts.ForeignKeyMember.Column
    }

    if(!$column)
    { return "" }

    $columnName = $column.Name
    if($columnName -and $columnName.Length -gt 0)
    {
        return ".ToColumn(`"$columnName`")"
    }
    else
    {
        return ""
    }
}

function Generate-MapJoinTable
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaNavigationMember]
        $navMember
    )

    [Telerik.OpenAccess.Metadata.MetaJoinTableAssociation] $association = $navMember.Association -as [Telerik.OpenAccess.Metadata.MetaJoinTableAssociation]
    if(!$association)
    { return "" }

    if($association.HasBothEnds() -and $association.TargetEnd -eq $navMember)
    { return "" }

    $joinTable = $association.JoinTable
    if(!$joinTable -or !$joinTable.Name)
    {
        return ".MapJoinTable()"
    }

    $sourceParts = [Telerik.OpenAccess.Metadata.MetadataWorker]::GetAssociationPartsForAssociation($association, [Telerik.OpenAccess.Metadata.AssociationPartType]::JoinTableSource)
    $sourcePType = $association.Source -as [Telerik.OpenAccess.Metadata.MetaPersistentType]
    $exp = @($sourceParts | % { Get-ColumnExpression -ownerType $sourcePType -part $_ -lambdaId "x" })
    
    $targetParts = [Telerik.OpenAccess.Metadata.MetadataWorker]::GetAssociationPartsForAssociation($association, [Telerik.OpenAccess.Metadata.AssociationPartType]::JoinTableTarget)
    $targetPType = $association.Target -as [Telerik.OpenAccess.Metadata.MetaPersistentType]
    $exp2 = @($targetParts | % { Get-ColumnExpression -ownerType $targetPType -part $_ -lambdaId "y" })
    $exp = $exp + $exp2

    $columnExpressions = [string]::Join(", ", $exp)
    if(!$columnExpressions)
    {
        return ".MapJoinTable()"
    }

    $parametersToken = "(x, y)"
    if($association.TargetEnd -eq $navMember)
    {
        $parametersToken = "(y, x)"
    }
    $mapJoinTableToken = ".MapJoinTable(""{0}"", {1} => new{{{2}}}).CreatePrimaryKeyFromForeignKeys()" -f $joinTable.Name, $parametersToken, $columnExpressions

    return $mapJoinTableToken
}

function Get-ColumnExpression
{
    [OutputType([System.String])]
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaPersistentType]
        $ownerType,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNull()][Telerik.OpenAccess.Metadata.MetaAssociationPart]
        $part,
        [Parameter(Position=2, Mandatory=$true)][ValidateNotNull()][string]
        $lambdaId
    )

    if(!$ownerType -or !$part)
    { return "" }

    $column = $part.ForeignKeyColumn
    if($column)
    {
        $targetField = $part.IdentityMember
        if(!$targetField)
        {
            $targetField = [Telerik.OpenAccess.Metadata.MetadataWorker]::FindMetaPrimitiveMemberMappedToColumn($part.IdentityColumn, $ownerType)
        }

        if($targetField -and $targetField.IsVisible -and $column.Name -and $targetField.PropertyName)
        {
            return "{0} = {1}.{2}" -f $column.Name, $lambdaId, $targetField.PropertyName
        }
    }

    return ""
}

function Write-File
{
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $fileName,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $content
    )

    # Check-out the file or ask for overwrite or ...
    # Apply timestamp for the generation

    try
    {
        $content = $Global:preamble + $content
        Set-Content -Path $fileName -Value $content
    }
    catch
    {
        Write-Host "Failed to write to file $fileName due to exception:" -ForegroundColor Red
        Write-Host $_.Exception.ToString() -ForegroundColor Red
    }
}

function Generate-DataLayer
{
    param
    (
        [Parameter(Position=0, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $csName,
        [Parameter(Position=1, Mandatory=$true)][ValidateNotNullOrEmpty()][System.String]
        $backend,
        [Parameter(Mandatory=$false)][System.String]
        $namespace,
        [Parameter(Mandatory=$false)][System.String]
        $contextName,
        [Parameter(Mandatory=$false)][System.String]
        $settingsFilePath
    )

    Write-Host "Generating Data Layer..."

    if(!(Test-Path -Path $Global:outputPath))
    {
        New-Item -Path $Global:outputPath -ItemType directory | Out-Null
    }

    $t = Add-Type -Path $Global:referencePath"\Telerik.OpenAccess.dll" -PassThru
    $version = [System.Reflection.AssemblyName]::GetAssemblyName($t[0].Assembly.Location).Version
    Write-Host "Telerik.OpenAccess assembly version is $version" -ForegroundColor Green

    Add-Type -Path $Global:referencePath"\Telerik.OpenAccess.Runtime.dll"
    Add-Type -Path $Global:referencePath"\Inflector.dll"

    $cfg = Load-ModelConfiguration $Global:projectDir
    $namespace = $cfg.Item1
    $ignoreTables = $cfg.Item2

    [Telerik.OpenAccess.Metadata.MetadataContainer] $metadata = Perform-Mapping $csName $backend

    # additional template variables
    $metadataSource = $csName + "MetadataSource"

    # templates
    $contextTemplate = [IO.File]::ReadAllText("$templatesPath\Context.txt")
    $iQueryableEndpointTemplate = [IO.File]::ReadAllText("$templatesPath\IQueryableEndpoint.txt")
    $entityClassTemplate = [IO.File]::ReadAllText("$templatesPath\EntityClass.txt")
    $primitePropTemplate = [IO.File]::ReadAllText("$templatesPath\PrimitiveProp.txt")
    $navRefPropTemplate = [IO.File]::ReadAllText("$templatesPath\NavRefProp.txt")
    $navListPropTemplate = [IO.File]::ReadAllText("$templatesPath\NavListProp.txt")
    $sourceTemplate = [IO.File]::ReadAllText("$templatesPath\FluentMapping.txt")
    $mapConfigurationTemplate = [IO.File]::ReadAllText("$templatesPath\MapConfiguration.txt")
    $identityPropMappingTemplate = [IO.File]::ReadAllText("$templatesPath\IdentityPropMapping.txt")
    $primitivePropMappingTemplate = [IO.File]::ReadAllText("$templatesPath\PrimitivePropMapping.txt")
    $associationTemplate = [IO.File]::ReadAllText("$templatesPath\AssociationMapping.txt")


    # context code generation
    $iQueryableEndpoints = ""
    foreach ($pType in $metadata.PersistentTypes | ? { !$ignoreTables.Contains($_.Table.Name) } )
    {
        $entityType = $pType.Name
        $entityTypePlural = [Inflector.Inflector]::Pluralize($entityType)
        $endpoint = Invoke-Expression "@`"`r`n$iQueryableEndpointTemplate`r`n`"@"
        $iQueryableEndpoints += $endpoint + "`r`n"

        Generate-EntityClass $pType $entityClassTemplate $primitePropTemplate $navRefPropTemplate $navListPropTemplate
    }

    $result = Invoke-Expression "@`"`r`n$contextTemplate`r`n`"@"
    $fileName = "$Global:contextOutputPath\$contextName"+"$Global:fileSuffix.cs"
    Write-File $fileName $result

    Generate-Mapping $metadata $csName $namespace $sourceTemplate $mapConfigurationTemplate $identityPropMappingTemplate $primitivePropMappingTemplate $associationTemplate $ignoreTables

    Write-Host "Done."

}

Generate-DataLayer $csName $backend -namespace $namespace -contextName $contextName